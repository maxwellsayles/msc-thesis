\documentclass{ucalgthes1}   
\usepackage[letterpaper,top=1in, bottom=1.22in, left=1.40in, right=0.850in]{geometry}
\usepackage{fancyhdr}
\fancyhead{}
\fancyfoot{}
\renewcommand{\headrulewidth}{0pt}
\fancyhead[RO,LE]{\thepage}  
\usepackage{hyperref}

\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{comment}
\usepackage{float}

\theoremstyle{plain}
\newtheorem{thm}{Theorem}[section]
\newtheorem{lemma}[thm]{Lemma}
\newtheorem{prop}[thm]{Proposition}
\newtheorem{cor}[thm]{Corollary}
\theoremstyle{definition}
\newtheorem{defn}[thm]{Definition}

\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}

\newcommand{\CC}{\mathbb{C}}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\KK}{\mathbb{K}}
\newcommand{\MM}{\mathcal{M}}
\newcommand{\OO}{\mathcal{O}}
\newcommand{\ZZ}{\mathbb{Z}}
\newcommand{\QQ}{\mathbb{Q}}
\newcommand{\NP}{\textrm{NP}}
\newcommand{\RRgtz}{\mathbb{R}_{>0}}
\newcommand{\ZZgtz}{\mathbb{Z}_{>0}}
\newcommand{\ZZgez}{\mathbb{Z}_{\ge 0}}
\newcommand{\QQgtz}{\mathbb{Q}_{>0}}
\newcommand{\QQgez}{\mathbb{Q}_{\ge 0}}
\newcommand{\matrixto}[2]{\left( \begin{array}{rr} #1 & #2 \end{array} \right)}
\newcommand{\matrixot}[2]{\left( \begin{array}{r} #1 \\ #2 \end{array} \right)}
\newcommand{\matrixtt}[4]{\left( \begin{array}{rr} #1 & #2 \\ #3 & #4 \end{array} \right)}
\newcommand{\ntoinfty}{\lim_{n \rightarrow \infty}}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\ceil}[1]{\left\lceil #1 \right\rceil}

%\setlength{\parindent}{0pt}
%\setlength{\parskip}{2ex} 

\begin{document}

\setcounter{chapter}{2}
\chapter{Exponentiation}

Exponentiation is a fairly fundamental group operation and is useful in many different contexts.  Diffie-Hellman key exchange is an example where two parties can jointly establish a shared secret key over an insecure channel.  
 The fundamental operation of Diffie-Hellman key exchange is group exponentiation. Another application discussed in more detail in this thesis is that of computing the order of a group element.  A common approach in this case is to exponentiate a group element to the product of several small prime powers.  The result is an element whose order is known to not contain any of these small prime powers.  As such, it has a smaller order.  The order of this new element is then computed using Shanks' baby-step giant-step algorithm.  Determining the order of an element can be useful in computing the structure of a group, or in factoring an integer that is associated with the group.  In these examples, being able to perform group exponentiation faster means that we can perform a Diffie-Hellman key exchange faster, or that we can compute the order of a group element more quickly.

In sections \ref{section:binary} and \ref{section:naf} we discuss standard exponentiation techniques that rely on a base 2 representation of the exponent.  These methods benefit when the cost of squaring a group element is less than the cost of composing two elements. The method using Non-Adjacent Form described in section \ref{section:naf} also benefits when the cost of computing the inverse of a group element is inexpensive or relatively free.  In section \ref{section:dbns} we introduce Double-Base Number Systems, which, as the name implies, are number systems that make use of multiple bases in the representation of a number.  In section \ref{section:dbnsMethods} we discuss some of methods to compute Double-Base representations found in the literature.  In this thesis, we pay particular attention to representations that use bases 2 and 3, since a representation using base 3 can benefit when the cost of cubing an element is less than the cost of multiplying an element with its square.


%%%%%%%%%%%%%%%%%%%%%%%%%
% BINARY EXPONENTIATION %
%%%%%%%%%%%%%%%%%%%%%%%%%
\bigbreak
\section{Binary Exponentiation}\label{section:binary}
The most common and well known method of exponentiation is that of binary exponentation.  This method is often used in Computer Science as an exercise to teach algorithms.  Let $g$ be an element in the group $\mathcal G$ and $n$ be an integer.  We want to compute $g^n \in \mathcal G$.  We first represent $n$ in binary as
\[
	n = \sum_{i=0}^{\floor{log_2 n}} b_i 2^i
\]
where $b_i \in \{0, 1\}$ such that $b_i$ represents the $i^{\textrm{th}}$ bit of $n$.   We compute $g^{2^i}$ by repeated squaring of $g$ and compute $g^n$ by computing
\[
	g^n = \prod_{i=0}^{\floor{log_2 n}} g^{b_i 2^i}.
\]
This description is known as right-to-left binary exponentiation as the result is computed by evaluating the bits of the exponent $n$ from right to left.  The left-to-right variant evaluates the bits of the exponent $n$ from left to right by repeatedly squaring the result and multiplying this with the base element $g$ when $b_i = 1$.  The left-to-right variant has the advantage that one of the values in the multiplication remains constant throughout the evaluation, namely $g$.  There also exist windowed variants where $g^w$ is precomputed for each $w$ in some window $0 \le w \le 2^k$ for some $k$ (typically chosen to be cache efficient). The exponent $n$ is then expressed in base $2^k$.  There are numerous sources discussing windowed variants such as (TODO) but, we do not discuss these variants further here.

Binary exponentiation algorithms require on average $\floor{log_2 n}$ squarings and $\floor{log_2 n}/2$ multiplications, since a multiplication is only necessary when $b_i = 1$ and the probability of $b_i = 1$ is 1/2.

%%%%%%%%%%%%%%%%%%%%%%
% NAF EXPONENTIATION %
%%%%%%%%%%%%%%%%%%%%%%
\bigbreak
\section{Non-Adjacent Form Exponentiation}\label{section:naf}

Non-Adjacent Form (NAF) refers to the representation of a number given a \emph{signed} base two representation.  That is, a number $n$ is represented such that
\[
	n = \sum_{i=0}^{\ceil{log_2 n}} s_i 2^i
\]
where $s_i \in \{0, 1, -1\}$.  As the name suggests, for a number to be in Non-Adjacent Form, there cannot be two non-zero terms adjacent in the representation.  For example, suppose $n = 40824$.  In a binary representation we have
\[
	n = 2^3+2^4+2^5+2^6+2^8+2^9+2^{10}+2^{11}+2^{12}+2^{15}
\]
and in Non-Adjacent Form we have
\[
	n = -2^3-2^7+2^{13}+2^{15}.
\]
Similar to the binary case, we compute $g^n$ using
\[
	g^n = \prod _{i=0}^{\ceil{log_2 n}} g^{s_i 2^i}.
\]
Since $s_i$ may be 0, 1, or -1, Non-Adjacent Form is particularly useful when the cost of computing $g^{-1}$ is relatively inexpensive (or essentially free as in the case of the ideal class group).  However, as we shall see below, we can minimize the number of inversions required to at most 1.

\begin{algorithm}[h]
\caption{Computes $g^n$ using a right-to-left NAF}\label{alg:nafr2l}
\begin{algorithmic}[1]
\REQUIRE $g \in \mathcal G, n \ge 0 \in \ZZ$
\ENSURE $g^n \in \mathcal G$
\STATE $i \gets 0$
\STATE $T \gets g$ \COMMENT{invariant: $T = g^{2^i}$}
\STATE $R \gets 1_{\mathcal G}$
\WHILE {$n \ge 2^i$}
	\IF {$\floor{n/2^i} \equiv 1 \pmod 4$}
		\STATE $R \gets R \cdot T$
		\STATE $n \gets n-2^i$
	\ELSIF {$\floor{n/2^i} \equiv 3 \pmod 4$}
		\STATE $R \gets R \cdot T^{-1}$
		\STATE $n \gets n+2^i$
	\ENDIF
	\STATE $T \gets T^2$
	\STATE $i \gets i + 1$
\ENDWHILE
\RETURN $R$
\end{algorithmic}
\end{algorithm}

There are various methods for evaluating $g^n$ when $n$ is given in Non-Adjacent Form.  As in the binary case, we can compute the evaluation left-to-right, right-to-left, and we can use windowing techniques.  A standard technique is to inspect $n$ from right-to-left two bits at a time.  If the bit pattern at index $i$ is 01, let $s_i = 1$ and subtract $2^i$ from $n$.  If the bit pattern is 11, let $s_i = -1$ and add $2^i$ to $n$.  When the bit pattern is 00 or 10, let $s_i =0$.  Algorithm \ref{alg:nafr2l} captures this idea while evaluating $g^n$ at the same time.

This method can be improved by maintaining a carry flag $c$; instead of adding $2^i$ to $n$, we instead let $c = 1$; instead of subtracting $2^i$ from $n$, we instead let $c = 0$.  The benefit is noticable for \emph{very} large $n$, since the cost of addition and subtraction is reduced from $O(\log n)$ to $O(1)$.  Furthermore, we can compute $g^n$ using at most one inversion by computing the product $Q = g^{s_i2^i}$ for all $s_i = -1$ separate from the product $R = g^{s_j2^j}$ for all $s_j = 1$.  The result is $g^n = R \cdot Q^{-1}$.  These improvements are given in algorithm \ref{alg:nafR2LImmutable} and in detail in \cite[p.4]{Joye2000}.  Note that integer computations such as ``$\floor{n/2^i} \bmod 4$'' can be performed by sliding a window of size 2 bits across the binary representation of $n$.

\begin{algorithm}[h]
\caption{Computes $g^n$ for immutable $n$ using only one inverse.}\label{alg:nafR2LImmutable}
\begin{algorithmic}[1]
\REQUIRE $g \in \mathcal G, n \ge 0 \in \ZZ$
\ENSURE $g^n \in \mathcal G$
\STATE $c \gets 0$ \COMMENT{carry flag}
\STATE $i \gets 0$
\STATE $R \gets 1_{\mathcal G}$ \COMMENT{product of positive exponents}
\STATE $Q \gets 1_{\mathcal G}$ \COMMENT{product of negative exponents}
\STATE $T \gets g$ \COMMENT{invariant: $T = g^{2^i}$}
\WHILE {$n \ge 2^i$}
	\IF {$\floor{n/2^i}+c \equiv 1 \pmod 4$}
		\STATE $R \gets R \cdot T$
		\STATE $c \gets 0$
	\ELSIF {$\floor{n/2^i}+c \equiv 3 \pmod 4$}
		\STATE $Q \gets Q \cdot T$ \\
		\STATE $c \gets 1$
	\ENDIF
	\STATE $T \gets T^2$ \\
	\STATE $i \gets i+1$
\ENDWHILE
\IF {$c=1$} \STATE $R \gets R \cdot T$ \ENDIF
\RETURN $R \cdot Q^{-1}$
\end{algorithmic}
\end{algorithm}

The particular advantage of a Non-Adjacent Form exponentiation over a binary exponentiation is in regards to the number of operations required.  While the binary method required $\floor{\log_2 n}$ squares and on average $\floor{\log_2 n}/2$ multiplications, a Non-Adjacent Form exponentiation requires at most $\floor{\log_2 n}+1$ squares and on average $\floor{\log_2 n}/3$ multiplications.  To see this, recall that Non-Adjacent Form requires that no two non-zero terms be adjacent.  Consider any two adjacent terms.  With probability 2/3 the first term is non-zero, in which case, the second term must be zero.  With probability 1/3 the first term is zero, in which case, the probability is 2/3 that the second term is non-zero.  This means that 2/3 of the time, 1 of 2 terms will be non-zero, and $1/3 \times 2/3$ of the time, 1 of 2 terms will be non-zero; so the probability of a given term being non zero is 1/3.


%%%%%%%%
% DBNS %
%%%%%%%%
\bigbreak
\section{Double-Base Number Systems}\label{section:dbns}

A significant advantage of Non-Adjacent Form over a binary representation is that on average the number of non-zero terms (the density of the representation) is lower.  This advantage is accentuated when we extend the representation to a signed double-base representation.  Given two coprime integers $p$ and $q$ and some integer $n$, we represent $n$ as the sum and difference of the product of powers of $p$ and $q$,
\[
	n = \sum_i s_i p^{a_i} q^{b_i}.
\]
For example, consider the number $n=40824$ as above.  Given the bases $p=2$ and $q=3$, we can represent $n$ as
\[
	n = 2^5 3^6 + 2^3 3^7 = (32)(729) + (8)(2187) = 23328 + 17496 = 40824.
\]

The exponentiation of $g^n$ is
\begin{align*}
	g^n = g^{2^5 3^6} g^{2^3 3^7}.
\


\pagebreak
\bigbreak
\subsection{When/why is it useful?}

\subsubsection {Sub-linearity in number of terms}

\bigbreak
\subsection{Chains vs Representations}


\bigbreak
\subsection{Encoding of chains/representations}
TODO: this seems like a concrete representation.  Should come later.


% END OF TODAY


\bigbreak
\section{Methods for computing 2,3 Chains/Representations}\label{section:dbnsMethods}

\bigbreak
\subsection{R2L Chains}

\bigbreak
\subsection{L2R Chains (Ostrowski approximation)}

\bigbreak
\subsection{Yao's method for representations}

\bigbreak
\subsection{Pruned Trees}




\begin{defn}
A non-increasing sequence of positive integers, called \emph{parts}, summing to $n$ is known as a \emph{partition} of $n$.
\end{defn}



\end{document}

