\documentclass[11pt, letterpaper]{article}

\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{fullpage}
\usepackage{comment}

\newtheorem*{thm}{Theorem}
\newtheorem*{lem}{Lemma}
\newtheorem*{cor}{Corollary}
\theoremstyle{definition}
\newtheorem*{defn}{Definition}


\parindent 0ex

\newcommand{\CC}{\mathbb{C}}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\RRgtz}{\mathbb{R}_{>0}}
\newcommand{\ZZ}{\mathbb{Z}}
\newcommand{\ZZgtz}{\mathbb{Z}_{>0}}
\newcommand{\ZZgez}{\mathbb{Z}_{\ge 0}}
\newcommand{\QQ}{\mathbb{Q}}
\newcommand{\QQgtz}{\mathbb{Q}_{>0}}
\newcommand{\QQgez}{\mathbb{Q}_{\ge 0}}
\newcommand{\NP}{\textrm{NP}}
\newcommand{\matrixot}[2]{\left( \begin{array}{r} #1 \\ #2 \end{array} \right)}
\newcommand{\matrixtt}[4]{\left( \begin{array}{rr} #1 & #2 \\ #3 & #4 \end{array} \right)}
\newcommand{\ntoinfty}{\lim_{n \rightarrow \infty}}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\ceil}[1]{\left\lceil #1 \right\rceil}


\begin{document}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% POWER PRIMORIAL EXPONENTIATION %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Exponentiation by power primorials}

We did not investigate window techniques.

\subsection{NAF-R2L}

\bigbreak
\begin{algorithm}[h!]
\caption{Computes $A^N$}
\label{NAF-R2l}
\begin{algorithmic}[1]
\REQUIRE $N \ge 0$ \\
\STATE $T \gets A$ \\
\STATE $R \gets 1_G$ \\
\WHILE {$N \ne 0$}
	\IF {$N \equiv 1 \pmod 4$}
		\STATE $R \gets R \cdot T$ \\
		\STATE $N \gets N-1$
	\ELSIF {$N \equiv 3 \pmod 4$}
		\STATE $R \gets R \cdot T^{-1}$ \\
		\STATE $N \gets N+1$
	\ENDIF
	\STATE $T \gets T^2$ \\
	\STATE $N \gets \frac{N}{2}$
\ENDWHILE
\RETURN $R$
\end{algorithmic}
\end{algorithm}

\bigbreak
This method can be improved by maintaining a carry flag $c$ and composing the inverses separately.  Let $Q$ be the composition of all inverses; initially $Q=1_G$.  Let $c$ be the carry flag; initially $c=1$.  We compute $m = (N+c) \bmod 4$.  When $m = 01$ in binary, we compute $R \gets R \cdot T$, and virtually subtract 1 from $N$ by clearing the carry.  When $m = 11$ in binary, we compute $Q \gets Q \cdot T$, and virtually add 1 to $N$ by setting the carry flag to 1. The result is $R \cdot Q^{-1}$.  See $\ref{Joye2000}$ for details.  The basic algorithm is given below.

\bigbreak
\begin{algorithm}[h!]
\caption{Computes $A^N$ without modifying $N$ and by performing only one inverse.}
\label{NAF-R2l}
\begin{algorithmic}[1]
\REQUIRE $N \ge 0$
\STATE $c \gets 0$
\STATE $i \gets 0$
\STATE $R \gets 1_G$
\STATE $Q \gets 1_G$
\STATE $T \gets A$
\WHILE {$N \ge 2^i$}
	\STATE $m \gets \left(\floor{\frac{N}{2^i}}+c\right) \bmod 4$
	\IF {$m = 1$}
		\STATE $R \gets R \cdot T$
		\STATE $c \gets 0$
	\ELSIF {$m = 3$}
		\STATE $Q \gets Q \cdot T$ \\
		\STATE $c \gets 1$
	\ENDIF
	\STATE $T \gets T^2$ \\
	\STATE $i \gets i+1$
\ENDWHILE
\IF {$c=1$} \STATE $R \gets R \cdot T$ \ENDIF
\RETURN $R \cdot Q^{-1}$
\end{algorithmic}
\end{algorithm}

\bigbreak
It is an improvement to leave $N$ unmodified since if $N$ is very large, as in our case, the overhead of even simple arithmetic operations, such as addition by 1, is noticeable.  Line 7 in the above can be computed by sliding a window of 2 bits across $N$.  This is significantly faster than performing actual division with floor.

\subsection{DBNS R2L chains $\pmod 3$ and $\pmod {2^23^2 = 36}$.}
\subsection{DBNS L2R chains}
\subsection{DBNS Closest approximation}
Greedy algorithm that finds
\[
	\min_{a,b} \left\{|N-2^a3^b| : 0 \le a \le A, 0 \le b \le B\right\}
\]

\subsection{$\pm 1$ and reduce}
Greedy 
\[
	S_{i+1} = \min \left\{ \left| \frac{N \pm 1}{2^c3^d} \right| : N \in S_i \right\}
\]
at each step keeping only the $x=16$ smallest elements of $S$.

\subsection{$\pm 2^a3^b$ and reduce}
Greedy algorithm that finds
\[
	\min_{a,b,c,d} \left\{\left| \frac{N \pm 2^a3^b}{2^c3^d} \right| \right\}
\]
such that $0 \le a \le A$, $0 \le c \le A$, $0 \le b \le B$, and $0 \le d \le B$ for all terms.

I also tried the above such that $0 \le c \le C$ and $0 \le d \le D$.

\subsection{$\pm 2^a \pm 3^b$ and reduce}
Greedy algorithm that finds
\[
	\min_{a,b,c,d} \left\{\left| \frac{N \pm 2^a \pm 3^b}{2^c3^d} \right| \right\}
\]

\subsection{Optimal Strictly Chained Partitions}
Recursive tree method that finds optimal \emph{strictly chained} partitions.

\subsection{Prunning variations}
Prunning variations, where I keep the \emph{best} $x$ solutions to the above and then iterate on the best solutions, repeatedly pruning at each step.

\subsection{Power Primorial vs list of Prime Powers}
Tried representing the primorial as $\prod p_i^{e_i}$, then as 16-bit blocks, and finally as computing $b_i=b_{i-1}^{p_i^{e_i}}$.

\subsection{Computing optimal representations for 16bit numbers}
For exponents 0 through 65535, we computed optimal chains.  These work best for list based representation of primorials as well as for powering by small exponents.

\subsection{Results}
All other methods work better for larger primorial.



\end{document}

